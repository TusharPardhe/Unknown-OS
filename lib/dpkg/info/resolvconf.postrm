#!/bin/sh

set -e

. /usr/share/debconf/confmodule

MYNAME=resolvconf.postrm
report() { echo "${MYNAME}: $*" ; }
report_info() { report "$*" >&2 ; }

is_installed() {
	# Same function in preinst, postinst, postrm
	[ "$1" ] || return 1
	dpkg-query -W -f='${Status}\n' "$1" 2>/dev/null | grep -siq '^[[:alpha:]]\+ [[:alpha:]]\+ installed$' >/dev/null 2>&1
}

# Automatically added by dh_installinit
if [ "$1" = "purge" ] ; then
	update-rc.d resolvconf remove >/dev/null
fi


# In case this system is running systemd, we make systemd reload the unit files
# to pick up changes.
if [ -d /run/systemd/system ] ; then
	systemctl --system daemon-reload >/dev/null || true
fi
# End automatically added section
# Automatically added by dh_systemd_enable
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/deb-systemd-helper" ]; then
		deb-systemd-helper mask resolvconf.service >/dev/null
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/deb-systemd-helper" ]; then
		deb-systemd-helper purge resolvconf.service >/dev/null
		deb-systemd-helper unmask resolvconf.service >/dev/null
	fi
fi
# End automatically added section
# Automatically added by dh_installdebconf
if [ "$1" = purge ] && [ -e /usr/share/debconf/confmodule ]; then
	. /usr/share/debconf/confmodule
	db_purge
fi
# End automatically added section


case "$1" in
  remove)
	if
		[ -L /etc/resolv.conf ] \
		&& [ "$(readlink /etc/resolv.conf)" = "/run/resolvconf/resolv.conf" ]
	then
		# /etc/resolv.conf is a resolvconf symlink

		#
		# Remove the symlink
		#
		rm -f /etc/resolv.conf

		#
		# Put a file at /etc/resolv.conf with best available content
		#
		# Best is latest dynamic content
		#
		if [ -f /run/resolvconf/resolv.conf ] ; then
			# (Remove "generated by resolvconf" comment which is no longer true)
			grep -sv '^#' /run/resolvconf/resolv.conf > /etc/resolv.conf || :
			rm -f /run/resolvconf/resolv.conf
			# If nothing is left over, remove the file entirely
			[ -s /etc/resolv.conf ] || rm -f /etc/resolv.conf
		fi
		# 
		# Second best is "original" content
		#
		if
			[ ! -f /etc/resolv.conf ] \
			&& [ -f /etc/resolvconf/resolv.conf.d/original ]
		then
			cp -a /etc/resolvconf/resolv.conf.d/original /etc/resolv.conf
		fi
	fi

	rm -f /var/lib/resolvconf/linkified

	report_info "Reboot recommended"
	db_input high resolvconf/reboot-recommended-after-removal || :
	db_go || :

	# Notify packages of the removal of resolvconf
	if [ -d /usr/lib/resolvconf/dpkg-event.d ] ; then
		NOTIFICATION_HOOK_SCRIPTS="$(cd /usr/lib/resolvconf/dpkg-event.d >/dev/null ; run-parts --test .)"
		for SCRPT in $NOTIFICATION_HOOK_SCRIPTS ; do
			PKG="${SCRPT#./}"
			if is_installed "$PKG" ; then
				SCRPT="/usr/lib/resolvconf/dpkg-event.d/$PKG"
				if [ -x "$SCRPT" ] ; then
					"$SCRPT" remove || :
				fi
			fi 
		done
	fi
	;;
  purge)
	#
	# Remove all remaining cruft
	#
	rm -f /etc/resolvconf/resolv.conf.d/tail
	rm -f /etc/resolvconf/resolv.conf.d/original
	rm -f /etc/resolvconf/update.d/bind
	rm -f /etc/resolvconf/update.d/bind.dpkg-old
	rm -f /etc/default/resolvconf
	rm -f /etc/dhcp3/dhclient-enter-hooks.d/resolvconf
	rm -f /etc/init.d/resolvconf.dpkg-old
	rm -f /etc/resolv.conf.dpkg-old
	rm -rf "/lib/init/rw/resolvconf" || :
	rm -rf /run/resolvconf || :
	;;
  # disappear|upgrade)
	# Don't do anything on upgrade
	# ;;
  # failed-upgrade)
	# Don't do anything because we don't do anything here (in the postrm) on upgrade
	# ;;
  abort-install)
	rm -f /run/resolvconf/packages-to-notify
	# In the preinst we create directories
	# but there is no immediate need to remove them if there is an error.
	;;
  # abort-upgrade)
	# Don't do anything.
	# In the preinst we create directories
	# but there is no immediate need to remove them if there is an error.
	# ;;

esac

exit 0
